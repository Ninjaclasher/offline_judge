#!/usr/bin/env python3

"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import subprocess
import resource
import mmap
import signal
import math

def mem_str(mem):
	return str(mem * 1024 // resource.getpagesize()) + "p/" + str(round(mem / 1024,2)) + "M"

def cpu_mem_str(cpu,mem):
	return mem_str(mem) + " " + str(round(cpu,4)) + "s"

def judge_case(file_i,file_o,cpu_limit,mem_limit,out_limit=None):
	r,w = os.pipe()
	os.set_inheritable(w,True)
	os.set_inheritable(2,True)
	pid = os.fork()
	if pid == 0:
		stdin = os.open(file_i,os.O_RDONLY)
		if stdin != 0:
			os.dup2(stdin,0)
			os.close(stdin)
		os.dup2(w,1)
		cpu_limit_sec = math.ceil(cpu_limit)
		resource.setrlimit(resource.RLIMIT_AS,(mem_limit,mem_limit))
		resource.setrlimit(resource.RLIMIT_CPU,(cpu_limit_sec,cpu_limit_sec))
		os.execv(sys.argv[4],[sys.argv[4]])
	submission = pid
	os.close(w)
	if out_limit == None:
		out_limit = os.stat(file_o).st_size
	result = os.read(r,mmap.PAGESIZE)
	while len(result) < out_limit:
		buf = os.read(r,mmap.PAGESIZE)
		if len(buf) == 0:
			break
		result += buf
	os.kill(submission,signal.SIGKILL)
	_,return_status,rusage = os.wait4(submission,0)
	return_signal = return_status & 0xff
	return_code = return_status >> 8
	if not (len(result) <= out_limit):
		return "OLE",rusage.ru_utime,rusage.ru_maxrss,return_status
	if return_signal == 9 or rusage.ru_utime > cpu_limit:
		return "TLE",rusage.ru_utime,rusage.ru_maxrss,return_status
	if return_signal != 0:
		return "RTE",rusage.ru_utime,rusage.ru_maxrss,return_status
	if return_code != 0:
		return "RE",rusage.ru_utime,rusage.ru_maxrss,return_status
	answer = open(file_o,"rb").read()
	if answer != result:
		return "WA",rusage.ru_utime,rusage.ru_maxrss,return_status
	return "AC",rusage.ru_utime,rusage.ru_maxrss,return_status

def main():
	if len(sys.argv) != 5:
		print(sys.argv[0] + " test_cases cpu_limit mem_limit executable")
		return 1
	MEMORY_UNIT = {
		"B": 2**0,
		"K" : 2**10,
		"M" : 2**20,
		"G" : 2**30,
	}
	STATUS_MASK = {
		"AC" : 0,
		"RTE" : 1,
		"MLE" : 2,
		"OLE" : 4,
		"TLE" : 8,
		"RE" : 16,
		"WA" : 32
	}
	RTE_STATUS = {
		4 : "Illegal instruction",
		6 : "Aborted",
		8 : "Floating point exception",
		11 : "Segmentation fault"
	}
	case_path = sys.argv[1]
	cpu_limit = float(sys.argv[2])
	mem_limit = (int(sys.argv[3][:-1]) * MEMORY_UNIT[sys.argv[3][-1:]]) & -mmap.PAGESIZE
	num_ac = 0
	status_mask = 0
	cpu_total = 0.0
	mem_total = 0
	num_cases = 0
	def recursive_judge(case,depth=-1):
		nonlocal cpu_total,mem_total,status_mask,num_cases,num_ac
		if os.path.isdir(case):
			if depth != -1:
				print(" " * 4 * depth + " - " + os.path.basename(case))
			for filename in sorted(os.listdir(case)):
				recursive_judge(os.path.join(case,filename),depth+1)
		elif case.endswith(".in") and os.path.isfile(case) and os.path.isfile(case[:-2] + "out"):
			file_out = case[:-2] + "out"
			verdict,cpu_usage,mem_usage,return_status = judge_case(case,file_out,cpu_limit,mem_limit,out_limit=os.path.getsize(file_out) * 4)
			cpu_total += cpu_usage
			mem_total = max(mem_usage,mem_total)
			status_mask |= STATUS_MASK[verdict]
			num_ac += verdict == "AC"
			num_cases += 1
			case_name_verdict = " " * 4 * depth + os.path.basename(case[:-3]) + ": " + verdict
			usage_str = cpu_mem_str(cpu_usage,mem_usage)
			if verdict == "WA" or verdict == "AC":
				print(case_name_verdict + " " + usage_str)
			elif verdict == "OLE":
				print(case_name_verdict + " " + usage_str)
			elif verdict == "TLE":
				print(case_name_verdict + "(>" + str(cpu_limit) + ") " + mem_str(mem_usage))
			elif verdict == "RTE":
				print(case_name_verdict + "(" + RTE_STATUS[return_status & 0x7f] + ") " + usage_str) # TODO: add a default when no dictionary message exists
			elif verdict == "RE":
				print(case_name_verdict + "(" + str(return_status >> 8) + ") " + usage_str)
	recursive_judge(case_path)
	print(str(num_ac) + "/" + str(num_cases) + " " + ("AC" if num_ac == num_cases else next(k for k,v in STATUS_MASK.items() if v == status_mask &- status_mask)) + " " + cpu_mem_str(cpu_total,mem_total))

if __name__ == "__main__":
	try:
		sys.exit(main())
	except KeyboardInterrupt:
		sys.exit(1)

#!/usr/bin/env python3

import sys
import os
import subprocess
import resource
import mmap
import signal
import math

def cpu_mem_str(cpu,mem):
	return str(mem * 1024 // resource.getpagesize()) + "p/" + str(round(mem / 1024,2)) + "M " + str(round(cpu,4)) + "s"

def main():
	if len(sys.argv) != 5:
		print(sys.argv[0] + " test_case_dir/ cpu_limit mem_limit executable")
		return 1
	case_path = sys.argv[1] + "/"
	cases = [x[:-3] for x in os.listdir(sys.argv[1]) if os.path.isfile(case_path + x) and x.endswith(".in")]
	MEMORY_UNIT = {
		"B": 2**0,
		"K" : 2**10,
		"M" : 2**20,
		"G" : 2**30,
	}
	cpu_limit = float(sys.argv[2])
	mem_limit = (int(sys.argv[3][:-1]) * MEMORY_UNIT[sys.argv[3][-1:]]) & -mmap.PAGESIZE
	case_prefix = os.path.commonprefix(cases)
	cases = [x[len(case_prefix):] for x in cases]
	try:
		cases = [int(x) for x in cases]
	except ValueError:
		pass
	cases = sorted(cases)
	STATUS_MASK = {
		"RTE" : 1,
		"MLE" : 2,
		"OLE" : 4,
		"TLE" : 8,
		"RE" : 16,
		"WA" : 32
	}
	accepted = 0
	status_mask = 0
	cpu_total = 0.0
	mem_total = 0
	for case in cases:
		case_name = str(case)
		case_full_name = case_path + case_prefix + case_name
		r,w = os.pipe()
		os.set_inheritable(w,True)
		os.set_inheritable(2,True)
		pid = os.fork()
		if pid == 0:
			stdin = os.open(case_full_name + ".in",os.O_RDONLY)
			if stdin != 0:
				os.dup2(stdin,0)
				os.close(stdin)
			os.dup2(w,1)
			cpu_limit_sec = math.ceil(cpu_limit)
			resource.setrlimit(resource.RLIMIT_AS,(mem_limit,mem_limit))
			resource.setrlimit(resource.RLIMIT_CPU,(cpu_limit_sec,cpu_limit_sec))
			os.execv(sys.argv[4],[sys.argv[4]])
		submission = pid
		os.close(w)
		output_limit = os.stat(case_full_name + ".out").st_size * 4
		result = os.read(r,mmap.PAGESIZE)
		while len(result) < output_limit:
			buf = os.read(r,mmap.PAGESIZE)
			if len(buf) == 0:
				break
			result += buf
		os.kill(submission,signal.SIGKILL)
		if not (len(result) <= output_limit):
			status_mask |= STATUS_MASK["OLE"]
			print(case_name + ": OLE")
			continue
		_,return_status,rusage = os.wait4(submission,0)
		cpu_total += rusage.ru_utime
		mem_total = max(mem_total,rusage.ru_maxrss)
		return_signal = return_status & 127
		return_code = return_status >> 8
		RTE_STATUS = {
			4 : "Illegal instruction",
			6 : "Aborted",
			8 : "Floating point exception",
			11 : "Segmentation fault"
		}
		if return_signal == 9 or rusage.ru_utime > cpu_limit:
			status_mask |= STATUS_MASK["TLE"]
			print(case_name + ": TLE(>" + str(cpu_limit) + ")")
			continue
		if return_signal != 0:
			status_mask |= STATUS_MASK["RTE"]
			print(case_name + ": RTE(" + RTE_STATUS[return_signal] + ")")
			continue
		if return_code != 0:
			status_mask |= STATUS_MASK["RE"]
			print(case_name + ": RE(" + str(return_code) + ")")
			continue
		rusage_str = cpu_mem_str(rusage.ru_utime,rusage.ru_maxrss)
		answer = open(case_full_name + ".out","rb").read()
		if answer != result:
			status_mask |= STATUS_MASK["WA"]
			print(case_name + ": WA " + rusage_str)
			continue
		print(case_name + ": AC " + rusage_str)
		accepted += 1
	print(str(accepted) + "/" + str(len(cases)) + " " + ("AC" if accepted == len(cases) else next(k for k,v in STATUS_MASK.items() if v == status_mask &- status_mask)) + " " + cpu_mem_str(cpu_total,mem_total))

if __name__ == "__main__":
	try:
		sys.exit(main())
	except KeyboardInterrupt:
		sys.exit(1)

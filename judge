#!/usr/bin/env python3

import argparse
import sys
import os
import subprocess
import resource
import mmap
import signal
import math
from enum import Enum

from checkers import identical, floats, standard
from ansi import ansi_style

def mem_str(mem):
    return str(mem * 1024 // resource.getpagesize()) + "p/" + str(round(mem / 1024,2)) + "M"

def cpu_mem_str(cpu, mem):
    return mem_str(mem) + " " + str(round(cpu,4)) + "s"

class Verdict(Enum):
    AC = 0
    RTE = 1 << 0
    MLE = 1 << 1
    OLE = 1 << 2
    TLE = 1 << 3
    RE = 1 << 4
    WA = 1 << 5

VERDICT_COLOUR = {
    Verdict.AC : "green",
    Verdict.RTE : "yellow",
    Verdict.MLE : "yellow",
    Verdict.OLE : "yellow",
    Verdict.TLE : "white",
    Verdict.RE : "yellow",
    Verdict.WA : "red",
}

def verdict_str(verdict, no_ansi):
    return ansi_style("#ansi[{}]({}|bold)".format(verdict.name, VERDICT_COLOUR[verdict]), no_ansi)

def check(judge_output, process_output, checker=standard):
    return checker(judge_output, process_output)

def judge_case(file_i, file_o, cpu_limit, mem_limit, executable, checker, out_limit=None):
    r,w = os.pipe()
    os.set_inheritable(w,True)
    os.set_inheritable(2,True)
    pid = os.fork()
    if pid == 0:
        stdin = os.open(file_i,os.O_RDONLY)
        if stdin != 0:
            os.dup2(stdin,0)
            os.close(stdin)
        os.dup2(w,1)
        cpu_limit_sec = math.ceil(cpu_limit)
        resource.setrlimit(resource.RLIMIT_AS,(mem_limit,mem_limit))
        resource.setrlimit(resource.RLIMIT_CPU,(cpu_limit_sec,cpu_limit_sec))
        os.execv(executable,[executable])
    submission = pid
    os.close(w)
    if out_limit is None:
        out_limit = os.stat(file_o).st_size
    result = os.read(r,mmap.PAGESIZE)
    while len(result) < out_limit:
        buf = os.read(r,mmap.PAGESIZE)
        if len(buf) == 0:
            break
        result += buf
    os.kill(submission,signal.SIGKILL)
    os.close(r)
    _,return_status,rusage = os.wait4(submission,0)
    # TODO: Other processes randomly sending signals can break this
    if not len(result) <= out_limit:
        return Verdict.OLE, rusage.ru_utime, rusage.ru_maxrss, return_status
    if os.WIFSIGNALED(return_status) and os.WTERMSIG(return_status) == signal.SIGKILL or rusage.ru_utime > cpu_limit:
        return Verdict.TLE, rusage.ru_utime, rusage.ru_maxrss, return_status
    if os.WIFSIGNALED(return_status):
        return Verdict.RTE, rusage.ru_utime, rusage.ru_maxrss, return_status
    if os.WEXITSTATUS(return_status) != 0:
        return Verdict.RE, rusage.ru_utime, rusage.ru_maxrss, return_status
    with open(file_o, "rb") as out:
        answer = out.read()
    if not check(answer, result, checker):
        return Verdict.WA, rusage.ru_utime, rusage.ru_maxrss, return_status
    return Verdict.AC, rusage.ru_utime, rusage.ru_maxrss, return_status

def main():
    checkers = {
        'standard' : standard,
        'floats'   : floats,
        'identical': identical,
    }
    parser = argparse.ArgumentParser(description="An offline judging tool.")
    parser.add_argument("test_cases", help="Directory that contains the test cases to judge with.")
    parser.add_argument("cpu_limit", type=float, help="Time limit.")
    parser.add_argument("mem_limit", help="Memory limit.")
    parser.add_argument("executable", help="File to run.")
    parser.add_argument("checker", default="standard", nargs="?", choices=checkers.keys(), help="Checker to be used to compare outputs.")
    parser.add_argument("--no-ansi", action="store_const", default=0, const=1)
    args = parser.parse_args()
    MEMORY_UNIT = {
        "B" : 2**0,
        "K" : 2**10,
        "M" : 2**20,
        "G" : 2**30,
    }
    RTE_MSG = {
        4 : "Illegal instruction",
        6 : "Aborted",
        8 : "Floating point exception",
        11 : "Segmentation fault"
    }
    case_path = args.test_cases
    cpu_limit = args.cpu_limit
    mem_limit = (int(args.mem_limit[:-1]) * MEMORY_UNIT[args.mem_limit[-1:]]) & -mmap.PAGESIZE
    executable = args.executable
    checker = checkers[args.checker]
    no_ansi = args.no_ansi
    num_ac = 0
    status_mask = 0
    cpu_total = 0.0
    mem_total = 0
    num_cases = 0
    def recursive_judge(case,depth=-1):
        nonlocal cpu_total,mem_total,status_mask,num_cases,num_ac
        if os.path.isdir(case):
            if depth != -1:
                print(ansi_style("#ansi[{}](yellow|bold)".format("{padding} - {basename}".format(padding=" " * depth, basename=os.path.basename(case))), no_ansi))
            for filename in sorted(os.listdir(case)):
                recursive_judge(os.path.join(case,filename),depth+1)
        elif case.endswith(".in") and os.path.isfile(case) and os.path.isfile(case[:-2] + "out"):
            file_out = case[:-2] + "out"
            verdict,cpu_usage,mem_usage,return_status = judge_case(case,file_out,cpu_limit,mem_limit,executable,checker,out_limit=os.path.getsize(file_out) * 4)
            cpu_total += cpu_usage
            mem_total = max(mem_usage,mem_total)
            status_mask |= verdict.value
            if verdict == Verdict.AC:
                num_ac += 1
            num_cases += 1
            usage_str = cpu_mem_str(cpu_usage,mem_usage)
            case_name = "{indent} {filename}: ".format(indent=" " * 4 * depth, filename=os.path.basename(case[:-3]))
            case_name_verdict = case_name + verdict_str(verdict, no_ansi)
            if verdict == Verdict.WA or verdict == Verdict.AC or verdict == Verdict.OLE:
                print("{} {}".format(case_name_verdict, usage_str))
            elif verdict == Verdict.TLE:
                print("{} (>{}) {}".format(case_name_verdict, cpu_limit, mem_str(mem_usage)))
            elif verdict == Verdict.RTE:
                signal = os.WTERMSIG(return_status)
                print("{} ({}) {}".format(case_name_verdict, RTE_MSG[signal] if signal in RTE_MSG else "signal " + str(status), usage_str))
            elif verdict == Verdict.RE:
                print("{} ({}) {}".format(case_name_verdict, os.WEXITSTATUS(return_status), usage_str))
    recursive_judge(case_path)
    print("{ac}/{total} {verdict} {usage}".format(ac=num_ac, total=num_cases, verdict=verdict_str(Verdict(status_mask & -status_mask), no_ansi), usage=cpu_mem_str(cpu_total,mem_total)))

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit(1)
